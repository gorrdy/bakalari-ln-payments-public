
const axios = require('axios');
const fs = require('fs');
const nodemailer = require('nodemailer');

// ğŸ’¡ KRITICKÃ‰: NaÄtenÃ­ promÄ›nnÃ½ch z lokÃ¡lnÃ­ho souboru .env
require('dotenv').config(); 

// --- 1. NAÄŒTENÃ PROMÄšNNÃCH A KONSTANT ---
// BAKALÃÅ˜I
const BAKALARI_BASE_URL = process.env.BAKALARI_BASE_URL;
const BAKALARI_USERNAME = process.env.BAKALARI_USERNAME;
const BAKALARI_PASSWORD = process.env.BAKALARI_PASSWORD;

// START DATE
const DEFAULT_START_DATE = '2024-01-01'; 
const START_DATE_ENV = process.env.START_DATE || DEFAULT_START_DATE; 
const LAST_CHECK_FILE = 'last_check.json'; // Tento soubor bude nynÃ­ uklÃ¡dat i dluh/zÅ¯statek

// LNBits & API
const LNBITS_HOST = process.env.LNBITS_HOST || 'https://lnbits.cz'; 
const LNBITS_WITHDRAW_KEY = process.env.LNBITS_WITHDRAW_KEY;
const LNBITS_WITHDRAW_ENDPOINT = process.env.LNBITS_WITHDRAW_ENDPOINT || '/withdraw/api/v1/links';
const EXCHANGE_RATE_API_URL = process.env.EXCHANGE_RATE_API_URL;

// ODMÄšNY V CZK - (NezapomeÅˆte, Å¾e 3, 4, 5 by mÄ›ly bÃ½t v .env nastaveny ZÃPORNÄš)
const REWARD_CONFIG = {
    1: parseFloat(process.env.REWARD_GRADE_1_CZK || 0),
    2: parseFloat(process.env.REWARD_GRADE_2_CZK || 0),
    3: parseFloat(process.env.REWARD_GRADE_3_CZK || 0),
    4: parseFloat(process.env.REWARD_GRADE_4_CZK || 0),
    5: parseFloat(process.env.REWARD_GRADE_5_CZK || 0)
};

// NOTIFIKACE
const NOTIFICATION_EMAIL = process.env.NOTIFICATION_EMAIL;
const SMTP_HOST = process.env.SMTP_HOST;
const SMTP_USER = process.env.SMTP_USER;
const SMTP_PASS = process.env.SMTP_PASS;

// --- 2. KONTROLA KRITICKÃCH SECRETÅ® A SMTP ---
if (!LNBITS_WITHDRAW_KEY || !BAKALARI_USERNAME || !BAKALARI_PASSWORD || !EXCHANGE_RATE_API_URL || !BAKALARI_BASE_URL) {
    console.error("ğŸ”´ KRITICKÃ CHYBA: ChybÃ­ klÃ­Äe BakalÃ¡Å™i nebo LNBITS_WITHDRAW_KEY/API URL.");
    process.exit(1);
}
let transporter;
if (SMTP_HOST) {
    transporter = nodemailer.createTransport({
        host: SMTP_HOST,
        port: 465,      
        secure: true,   
        auth: { user: SMTP_USER, pass: SMTP_PASS }
    });
}


// --- 3. FUNKCE PRO KOMUNIKACI S BAKALÃÅ˜I ---

async function findWorkingEndpoint(baseUrl) {
    const possiblePrefixes = [
        '', '/bakalari', '/bakaweb', '/webrodice', '/dm', '/mobile'
    ];

    console.log(`DIAGNOSTIKA: HledÃ¡m funkÄnÃ­ API endpoint na ${baseUrl}...`);

    for (const prefix of possiblePrefixes) {
        const testUrl = `${baseUrl}${prefix}/api/login`;
        const params = new URLSearchParams();
        params.append('client_id', 'ANDR');
        params.append('grant_type', 'password');
        params.append('username', 'test');
        params.append('password', 'test');

        try {
            await axios.post(testUrl, params, {
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
            });
        } catch (error) {
            if (error.response && (error.response.status === 400 || error.response.status === 401)) {
                const foundApiBase = `${baseUrl}${prefix}/api`;
                console.log(`âœ… NALEZEN FUNKÄŒNÃ ENDPOINT: ${foundApiBase}`);
                return foundApiBase;
            }
        }
    }
    throw new Error("API endpoint nenalezen na Å¾Ã¡dnÃ© znÃ¡mÃ© cestÄ›.");
}

async function authenticateBakalari(username, password, apiBaseUrl) {
    const authUrl = `${apiBaseUrl}/login`;
    const params = new URLSearchParams();
    params.append('client_id', 'ANDR');
    params.append('grant_type', 'password');
    params.append('username', username);
    params.append('password', password);

    try {
        const response = await axios.post(authUrl, params, {
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
        return response.data?.access_token;
    } catch (error) {
        throw new Error(`PÅ™ihlÃ¡Å¡enÃ­ selhalo: ${error.message}`);
    }
}

async function fetchMarksViaApi(lastCheckDate) {
    console.log(`DIAGNOSTIKA: SpouÅ¡tÃ­m proces zÃ­skÃ¡nÃ­ znÃ¡mek...`);
    
    const apiBaseUrl = await findWorkingEndpoint(BAKALARI_BASE_URL);
    const token = await authenticateBakalari(BAKALARI_USERNAME, BAKALARI_PASSWORD, apiBaseUrl);
    
    console.log("DIAGNOSTIKA: BakalÃ¡Å™i pÅ™ihlÃ¡Å¡enÃ­ ÃºspÄ›Å¡nÃ©.");

    const marksUrl = `${apiBaseUrl}/3/marks`; 
    
    try {
        const response = await axios.get(marksUrl, {
            headers: { 'Authorization': `Bearer ${token}` }
        });

        let newMarks = [];
        const subjects = response.data?.Subjects || response.data?.Marks || [];
        
        subjects.forEach(subject => {
            const subjectName = subject.Caption || subject.Name || subject.SubjectName || 'NeznÃ¡mÃ½ pÅ™edmÄ›t'; 
            (subject.Marks || []).forEach(mark => processMark(mark, subjectName, lastCheckDate, newMarks));
        });
        
        console.log(`DIAGNOSTIKA: Nalezeno ${newMarks.length} novÃ½ch znÃ¡mek.`);
        return { marks: newMarks };

    } catch (error) {
        console.error('ğŸ”´ CHYBA PÅ˜I ZÃSKÃVÃNÃ ZNÃMEK:', error.message);
        throw error;
    }
}

function processMark(mark, subjectName, lastCheckDate, collection) {
    const markDate = new Date(mark.Date || mark.MarkDate); 
    
    if (markDate > lastCheckDate && mark.MarkText) {
        collection.push({
            date: markDate,
            value: mark.MarkText.trim(),
            subject: subjectName
        });
    }
}


// --- 4. OSTATNÃ FUNKCE ---

function mapGradeToNumeric(gradeString) {
    return parseInt(gradeString.replace(/[\+\-]/g, ''), 10);
}

// Funkce nynÃ­ poÄÃ­tÃ¡ POUZE ZMÄšNU z novÃ½ch znÃ¡mek (mÅ¯Å¾e bÃ½t kladnÃ¡ nebo zÃ¡pornÃ¡)
function computeCzkChangeFromMarks(marks) {
    let czkTotal = 0;
    
    marks.forEach(mark => {
        const numericGrade = mapGradeToNumeric(mark.value);
        const reward = REWARD_CONFIG[numericGrade];
        
        if (reward !== undefined) {
            czkTotal += reward;
        } else {
             console.warn(`UpozornÄ›nÃ­: Pro znÃ¡mku ${mark.value} neexistuje definovanÃ¡ odmÄ›na.`);
        }
    });
    return czkTotal;
}

async function getBtcPerCzk() {
    try {
        const response = await axios.get(EXCHANGE_RATE_API_URL);
        const czkRate = response.data?.bitcoin?.czk;
        if (!czkRate || typeof czkRate !== 'number') {
            throw new Error("NeplatnÃ¡ odpovÄ›Ä z API kurzu.");
        }
        console.log(`DIAGNOSTIKA: 1 BTC = ${czkRate} CZK.`);
        return czkRate;
    } catch (error) {
        console.error('ğŸ”´ CHYBA ZÃSKÃNÃ KURZU:', error.message);
        return 1500000; 
    }
}

function czkToSats(czkAmount, czkPerBtc) {
    const satsPerBtc = 100000000;
    const btcAmount = czkAmount / czkPerBtc;
    return Math.round(btcAmount * satsPerBtc);
}


async function createWithdrawVoucher(czkTotal, czkPerBtc) {
    // VypoÄÃ­tÃ¡me SATS (napÅ™. 21533)
    const totalSats = czkToSats(czkTotal, czkPerBtc);
    
    // Do API posÃ­lÃ¡me rovnou ÄÃ­slo v SATS
    const apiValue = totalSats; 
    
    // PonechÃ¡n klÃ­ÄovÃ½ diagnostickÃ½ log pro koneÄnou kontrolu
    console.log(`DIAGNOSTIKA: OdmÄ›na: ${czkTotal.toFixed(2)} CZK. PÅ™epoÄet: ${totalSats} sats. Hodnota odesÃ­lanÃ¡ API: ${apiValue}.`);

    if (totalSats <= 0) {
        console.log('DIAGNOSTIKA: CelkovÃ¡ odmÄ›na je 0 nebo zÃ¡pornÃ¡. Voucher nebude vytvoÅ™en.');
        return { success: true, message: "Bez platby." };
    }
    
    const apiUrl = `${LNBITS_HOST}${LNBITS_WITHDRAW_ENDPOINT}`;
    
    const voucherData = {
        title: `OdmÄ›na za znÃ¡mky (${czkTotal.toFixed(2)} CZK)`,
        min_withdrawable: apiValue, 
        max_withdrawable: apiValue, 
        uses: 1, 
        is_unique: true,
        wait_time: 1 
    };

    try {
        const response = await axios.post(apiUrl, voucherData, {
            headers: {
                'X-Api-Key': LNBITS_WITHDRAW_KEY,
                'Content-Type': 'application/json'
            }
        });

        const lnurl = response.data?.lnurl;

        if (!lnurl) {
            throw new Error("API nevrÃ¡tilo platnÃ½ LNURL.");
        }
        
        console.log('âœ… VOUCHER ÃšSPÄšÅ NÄš VYTVOÅ˜EN!');
        
        if (transporter) {
            await sendVoucherEmail(lnurl, czkTotal, totalSats); 
        } else {
             console.warn('âš ï¸ E-mailovÃ¡ notifikace pÅ™eskoÄena: ChybÃ­ nastavenÃ­ SMTP.');
        }
        
        return { success: true, lnurl: lnurl };

    } catch (err) {
        console.error('ğŸ”´ CHYBA PÅ˜I TVORBÄš VOUCHERU:', err.response?.data || err.message);
        throw new Error(`VolÃ¡nÃ­ Withdraw API selhalo: Request failed with status code ${err.response?.status || 500}`);
    }
}

async function sendVoucherEmail(lnurl, czkTotal, totalSats) {
    
    const qrCodeUrl = `${LNBITS_HOST}/api/v1/qrcode?data=${encodeURIComponent(lnurl)}`;
    
    const emailBody = `
        <p>Ahoj,</p>
        <p>AutomatickÃ½ systÃ©m BakalÃ¡Å™i zaznamenal TvÃ© novÃ© znÃ¡mky a vypoÄÃ­tal odmÄ›nu.</p>
        <p>CelkovÃ¡ odmÄ›na: <b>${czkTotal.toFixed(2)} CZK</b></p>
        <p>V pÅ™epoÄtu na krypto: <b>${totalSats} sats</b></p>
        <br>
        
        <h3>PotvrzenÃ­ o vÃ½bÄ›ru</h3>
        <p>Tento Lightning voucher je pÅ™ipraven k vÃ½bÄ›ru. Jakmile bude kÃ³d pouÅ¾it, penÃ­ze budou okamÅ¾itÄ› odeslÃ¡ny do TvÃ© penÄ›Å¾enky.</p>
        <p>Stav voucheru si mÅ¯Å¾eÅ¡ zkontrolovat na ${LNBITS_HOST}.</p>
        <br>
        
        <p>Pro vybrÃ¡nÃ­ odmÄ›ny naskenuj tento QR kÃ³d ve svÃ© Lightning penÄ›Å¾ence:</p>
        
        <img src="${qrCodeUrl}" alt="QR Code" style="width: 200px; height: 200px; border: 1px solid #ccc;"/>
        
        <p>Nebo pouÅ¾ij tento odkaz:</p>
        <p><a href="${lnurl}">${lnurl}</a></p>
        <p>SystÃ©m BakalÃ¡Å™i/LNbits.</p>
    `;

    try {
        await transporter.sendMail({
            from: `"${SMTP_USER}" <${SMTP_USER}>`,
            to: NOTIFICATION_EMAIL,
            subject: `ğŸ’° NovÃ¡ odmÄ›na: ${totalSats} sats (${czkTotal.toFixed(0)} CZK) - K VYZVEDNUTÃ`,
            html: emailBody
        });
        console.log(`âœ… E-mail s voucherem odeslÃ¡n (OdmÄ›na: ${totalSats} sats).`);
    } catch (error) {
        console.error('ğŸ”´ CHYBA PÅ˜I ODESÃLÃNÃ E-MAILU:', error.message);
    }
}


// --- 5. HLAVNÃ FUNKCE SKRIPTU (S LOGIKOU TRVALÃ‰HO ZÅ®STATKU) ---
async function main() {
    console.log('DIAGNOSTIKA: Vstup do main funkce. SpouÅ¡tÃ­m kontrolu prospektu...');
    
    try {
        let lastCheckDate = new Date(START_DATE_ENV);
        // ğŸ’¡ NovÃ¡ promÄ›nnÃ¡ pro uklÃ¡dÃ¡nÃ­ dluhu/zÅ¯statku
        let runningBalanceCzk = 0; 
        
        // 1. NAÄŒTENÃ PÅ˜EDCHOZÃHO ZÅ®STATKU A DATA KONTROLY
        if (fs.existsSync(LAST_CHECK_FILE)) {
            const data = JSON.parse(fs.readFileSync(LAST_CHECK_FILE, 'utf8'));
            lastCheckDate = new Date(data.last_checked || START_DATE_ENV);
            
            // ğŸ’¡ PÅ™idÃ¡na odolnost: NaÄte hodnotu 'running_balance_czk' (nebo 0, pokud soubor nemÃ¡ starÃ½ formÃ¡t)
            runningBalanceCzk = parseFloat(data.running_balance_czk) || 0; 
            
            console.log(`DIAGNOSTIKA: Nalezen soubor ${LAST_CHECK_FILE}. PÅ™edchozÃ­ dluh/zÅ¯statek: ${runningBalanceCzk.toFixed(2)} CZK.`);
        } else {
             console.warn(`âš ï¸ UPOZORNÄšNÃ: Soubor ${LAST_CHECK_FILE} nenalezen. ZaÄÃ­nÃ¡m s 0 CZK a od data: ${lastCheckDate.toISOString()}.`);
        }
        
        lastCheckDate = new Date(lastCheckDate.getTime() - 1); 

        const marksData = await fetchMarksViaApi(lastCheckDate);
        if (marksData.marks.length === 0) {
            console.log("DIAGNOSTIKA: Å½Ã¡dnÃ© novÃ© znÃ¡mky k proplacenÃ­.");
            // ğŸ’¡ UklÃ¡dÃ¡me stÃ¡vajÃ­cÃ­ dluh/zÅ¯statek, i kdyÅ¾ se nic nezmÄ›nilo
            fs.writeFileSync(LAST_CHECK_FILE, JSON.stringify({ 
                last_checked: new Date(),
                running_balance_czk: runningBalanceCzk 
            }), 'utf8');
            return;
        }

        // 2. VÃPOÄŒET ZMÄšNY Z NOVÃCH ZNÃMEK
        // PouÅ¾Ã­vÃ¡me stÃ¡vajÃ­cÃ­ funkci, jen ji pÅ™ejmenujeme pro sÃ©mantickou Äistotu
        const czkChangeFromMarks = computeCzkChangeFromMarks(marksData.marks); 
        
        // 3. VÃPOÄŒET NOVÃ‰HO CELKOVÃ‰HO ZÅ®STATKU
        const newRunningBalance = runningBalanceCzk + czkChangeFromMarks;
        let paymentAmountCzk = 0;
        let balanceToSave = 0;

        if (newRunningBalance > 0) {
            // ZÅ¯statek je kladnÃ½ -> proplatÃ­me ho celÃ½ a zÅ¯statek vynulujeme
            paymentAmountCzk = newRunningBalance;
            balanceToSave = 0;
            console.log(`DIAGNOSTIKA: ZÅ¯statek (+dluh): ${runningBalanceCzk.toFixed(2)} CZK. NovÃ¡ zmÄ›na: ${czkChangeFromMarks.toFixed(2)} CZK. CelkovÃ¡ odmÄ›na k platbÄ›: ${paymentAmountCzk.toFixed(2)} CZK.`);
        } else {
            // ZÅ¯statek je nula nebo zÃ¡pornÃ½ -> neplatÃ­me a dluh uloÅ¾Ã­me
            paymentAmountCzk = 0;
            balanceToSave = newRunningBalance;
            console.log(`DIAGNOSTIKA: ZÅ¯statek (+dluh): ${runningBalanceCzk.toFixed(2)} CZK. NovÃ¡ zmÄ›na: ${czkChangeFromMarks.toFixed(2)} CZK. NovÃ½ dluh k uloÅ¾enÃ­: ${balanceToSave.toFixed(2)} CZK. Platba se neuskuteÄnÃ­.`);
        }

        if (paymentAmountCzk <= 0) {
            // UloÅ¾enÃ­ dluhu a ukonÄenÃ­
            fs.writeFileSync(LAST_CHECK_FILE, JSON.stringify({ 
                last_checked: new Date(),
                running_balance_czk: balanceToSave 
            }), 'utf8');
            return;
        }

        // 4. PLATBA (POUZE, POKUD paymentAmountCzk > 0)
        const czkPerBtc = await getBtcPerCzk();
        
        // VytvÃ¡Å™Ã­me voucher s celkovou KLADNOU ÄÃ¡stkou
        const voucherResult = await createWithdrawVoucher(paymentAmountCzk, czkPerBtc);
        
        // 5. ULOÅ½ENÃ STAVU PO ÃšSPÄšÅ NÃ‰ PLATBÄš
        if (voucherResult.success) {
            // UklÃ¡dÃ¡me NULU, protoÅ¾e celÃ½ kladnÃ½ zÅ¯statek jsme proplatili (balanceToSave je 0 v tomto bloku)
            fs.writeFileSync(LAST_CHECK_FILE, JSON.stringify({ 
                last_checked: new Date(),
                running_balance_czk: balanceToSave // Bude 0
            }), 'utf8');
            console.log('DIAGNOSTIKA: Automatizace dokonÄena. Datum kontroly a zÅ¯statek aktualizovÃ¡ny.');
        }
        
    } catch (err) {
        console.error('ğŸ”´ KRITICKÃ CHYBA v main funkci:', err.message || err);
    }
}


// --- PÅ˜EJMENOVÃNÃ FUNKCE PRO LOGIKU ---
// PÅ™ejmenovÃ¡vÃ¡me, aby odpovÃ­dala novÃ© sÃ©mantice (Compute CHANGE from Marks)
const computeCzkAmountFromMarks = computeCzkChangeFromMarks; 
// ğŸ’¡ PoznÃ¡mka: PÅ¯vodnÃ­ nÃ¡zev funkce computeCzkAmountFromMarks je nahrazen funkcÃ­ computeCzkChangeFromMarks pro zpÄ›tnou kompatibilitu volÃ¡nÃ­ v kÃ³du, ale tÄ›lo je upravenÃ©.

// --- SPUÅ TÄšNÃ ---
if (require.main === module) main();
